#### Discrete Mathematics with Applications - 5th Edition

    [ ] Chapter 1: Speaking Mathematically
    
        [ ] 1.1 Variables
        [ ] 1.2 The Language of Sets
        [ ] 1.3 The Language of Relations and Functions
        [ ] 1.4 The Language of Graphs
        
    [ ] Chapter 2: The Logic of Compound Statements
    
        [ ] 2.1 Logical Form and Logical Equivalence
        [ ] 2.2 Conditional Statements
        [ ] 2.3 Valid and Invalid Arguments
        [ ] 2.4 Application: Digital Logic Circuits
        [ ] 2.5 Application: Number Systems and Circuits for Addition
        
    [ ] Chapter 3: The Logic of Quantified Statements
    
        [ ] 3.1 Predicates and Quantified Statements I
        [ ] 3.2 Predicates and Quantified Statements II
        [ ] 3.3 Statements with Multiple Quantifiers
        [ ] 3.4 Arguments with Quantified Statements
        
    [ ] Chapter 4: Elementary Number Theory and Methods of Proof
    
        [ ] 4.1 Direct Proof and Counterexample I: Introduction
        [ ] 4.2 Direct Proof and Counterexample II: Writing Advice
        [ ] 4.3 Direct Proof and Counterexample III: Rational Numbers
        [ ] 4.4 Direct Proof and Counterexample IV: Divisibility
        [ ] 4.5 Direct Proof and Counterexample V: Division into Cases and the Quotient-Remainder Theorem
        [ ] 4.6 Direct Proof and Counterexample VI: Floor and Ceiling
        [ ] 4.7 Indirect Argument: Contradiction and Contraposition
        [ ] 4.8 Indirect Argument: Two Famous Theorems
        [ ] 4.9 Application: The Handshake Theorem
        [ ] 4.10 Application: Algorithms
        
    [ ] Chapter 5: Sequences, Mathematical Induction, and Recursion
    
        [ ] 5.1 Sequences
        [ ] 5.2 Mathematical Induction I: Proving Formulas
        [ ] 5.3 Mathematical Induction II: Applications
        [ ] 5.4 Strong Mathematical Induction and the Well-Ordering Principle for the Integers
        [ ] 5.5 Application: Correctness of Algorithms
        [ ] 5.6 Defining Sequences Recursively
        [ ] 5.7 Solving Recurrence Relations by Iteration
        [ ] 5.8 Second-Order Linear Homogeneous Recurrence Relations with Constant Coefficients
        [ ] 5.9 General Recursive Definitions and Structural Induction
        
    [ ] Chapter 6: Set Theory
    
        [ ] 6.1 Set Theory: Definitions and the Element Method of Proof
        [ ] 6.2 Properties of Sets
        [ ] 6.3 Disproofs and Algebraic Proofs
        [ ] 6.4 Boolean Algebras, Russell's Paradox, and the Halting Problem
        
    [ ] Chapter 7: Properties of Functions
    
        [ ] 7.1 Functions Defined on General Sets
        [ ] 7.2 One-to-One, Onto, and Inverse Functions
        [ ] 7.3 Composition of Functions
        [ ] 7.4 Cardinality with Applications to Computability
        
    [ ] Chapter 8: Properties of Relations
    
        [ ] 8.1 Relations on Sets
        [ ] 8.2 Reflexivity, Symmetry, and Transitivity
        [ ] 8.3 Equivalence Relations
        [ ] 8.4 Modular Arithmetic with Applications to Cryptography
        [ ] 8.5 Partial Order Relations
        
    [ ] Chapter 9: Counting and Probability
    
        [ ] 9.1 Introduction to Probability
        [ ] 9.2 Possibility Trees and the Multiplication Rule
        [ ] 9.3 Counting Elements of Disjoint Sets: The Addition Rule
        [ ] 9.4 The Pigeonhole Principle
        [ ] 9.5 Counting Subsets of a Set: Combinations
        [ ] 9.6 r-Combinations with Repetition Allowed
        [ ] 9.7 Pascal's Formula and the Binomial Theorem
        [ ] 9.8 Probability Axioms and Expected Value
        [ ] 9.9 Conditional Probability, Bayes' Formula, and Independent Events
        
    [ ] Chapter 10: Theory of Graphs and Trees
    
        [ ] 10.1 Trails, Paths, and Circuits
        [ ] 10.2 Matrix Representations of Graphs
        [ ] 10.3 Isomorphisms of Graphs
        [ ] 10.4 Trees: Examples and Basic Properties
        [ ] 10.5 Rooted Trees
        [ ] 10.6 Spanning Trees and a Shortest Path Algorithm
        
    [ ] Chapter 11: Analysis of Algorithm Efficiency
    
        [ ] 11.1 Real-Valued Functions of a Real Variable and Their Graphs
        [ ] 11.2 Big-O, Big-Omega, and Big-Theta Notations
        [ ] 11.3 Application: Analysis of Algorithm Efficiency I
        [ ] 11.4 Exponential and Logarithmic Functions: Graphs and Orders
        [ ] 11.5 Application: Analysis of Algorithm Efficiency II
        
    [ ] Chapter 12: Regular Expressions and Finite-State Automata
    
        [ ] 12.1 Formal Languages and Regular Expressions
        [ ] 12.2 Finite-State Automata
        [ ] 12.3 Simplifying Finite-State Automata

####

Introduction
I The Interview
1 Getting Ready
2 Strategies For A Great Interview
3 Conducting An Interview
II Data Structures and Algorithms		22	(288)
4 Primitive Types
4.1 Computing the parity of a word
4.2 Swap bits
4.3 Reverse bits
4.4 Find a closest integer with the same weight
4.5 Compute x times y without arithmetical operators
4.6 Compute x/y
4.7 Compute xto the y power
4.8 Reverse digits
4.9 Check if a decimal integer is a palindrome
4.10 Generate uniform random numbers
4.11 Rectangle intersection
5 Arrays
5.1 The Dutch national flag problem
5.2 Increment an arbitrary-precision integer
5.3 Multiply two arbitrary-precision integers
5.4 Advancing through an array
5.5 Delete duplicates from a sorted array
5.6 Buy and sell a stock once
5.7 Buy and sell a stock twice
5.8 Computing an alternation
5.9 Enumerate all primes to n
5.10 Permute the elements of an array
5.11 Compute the next permutation
5.12 Sample offline data
5.13 Sample online data
5.14 Compute a random permutation
5.15 Compute a random subset
5.16 Generate nonuniform random numbers
5.17 The Sudoku checker problem
5.18 Compute the spiral ordering of a 2D array
5.19 Rotate a 2D array
5.20 Compute rows in Pascal's Triangle
6 Strings
6.1 Interconvert strings and integers
6.2 Base conversion
6.3 Compute the spreadsheet column encoding
6.4 Replace and remove
6.5 Test palindromicity
6.6 Reverse all the words in a sentence
6.7 Compute all mnemonics for a phone number
6.8 The look-and-say problem
6.9 Convert from Roman to decimal
6.10 Compute all valid IP addresses
6.11 Write a string sinusoidally
6.12 Implement run-length encoding
6.13 Find the first occurrence of a substring
7 Linked Lists
7.1 Merge two sorted lists
7.2 Reverse a single sublist
7.3 Test for cyclicity
7.4 Test for overlapping lists-lists are cycle-free
7.5 Test for overlapping lists-lists may have cycles
7.6 Delete a node from a singly linked list
7.7 Remove the kth last element from a list
7.8 Remove duplicates from a sorted list
7.9 Implement cyclic right shift for singly linked lists
7.10 Implement even-odd merge
7.11 Test whether a singly linked list is palindromic
7.12 Implement list pivoting
7.13 Add list-based integers
8 Stacks and Queues
8.1 Implement a stack with max API
8.2 Evaluate RPN expressions
8.3 Test a string over "{,},(,),[ ,]" for well-formedness
8.4 Normalize pathnames
8.5 Search a postings list
8.6 Compute buildings with a sunset view
8.7 Compute binary tree nodes in order of increasing depth
8.8 Implement a circular queue
8.9 Implement a queue using stacks
8.10 Implement a queue with max API
9 Binary Trees
9.1 Test if a binary tree is height-balanced
9.2 Test if a binary tree is symmetric
9.3 Compute the lowest common ancestor in a binary tree
9.4 Compute the LCA when nodes have parent pointers
9.5 Sum the root-to-leaf paths in a binary tree
9.6 Find a root to leaf path with specified sum
9.7 Implement an inorder traversal without recursion
9.8 Implement a preorder traversal without recursion
9.9 Compute the kth node in an inorder traversal
9.10 Compute the successor
9.11 Implement an inorder traversal with O(1) space
9.12 Reconstruct a binary tree from traversal data
9.13 Reconstruct a binary tree from a preorder traversal with markers
9.14 Form a linked list from the leaves of a binary tree
9.15 Compute the exterior of a binary tree
9.16 Compute the right sibling tree
9.17 Implement locking in a binary tree
10 Heaps
10.1 Merge sorted files
10.2 Sort an increasing-decreasing array
10.3 Sort an almost-sorted array
10.4 Compute the k closest stars
10.5 Compute the median of online data
10.6 Compute the k largest elements in a max-heap
10.7 Implement a stack API using a heap
11 Searching
11.1 Search a sorted array for first occurrence of k
11.2 Search a sorted array for entry equal to its index
11.3 Search a cyclically sorted array
11.4 Compute the integer square root
11.5 Compute the real square root
151	(1)
11.6 Search in a 2D sorted array
152	(2)
11.7 Find the min and max simultaneously
154	(1)
11.8 Find the kth largest element
155	(2)
11.9 Find the missing IP address
157	(1)
11.10 Find the duplicate and missing elements
158	(3)
12 Hash Tables
161	(23)
12.1 Test for palindromic permutations
165	(1)
12.2 Is an anonymous letter constructible?
166	(1)
12.3 Implement an ISBN cache
167	(1)
12.4 Compute the LCA, optimizing for close ancestors
168	(1)
12.5 Compute the k most frequent queries
169	(1)
12.6 Find the nearest repeated entries in an array
170	(1)
12.7 Find the smallest subarray covering all values
171	(3)
12.8 Find smallest subarray sequentially covering all values
174	(1)
12.9 Find the longest subarray with distinct entries
175	(1)
12.10 Find the length of a longest contained interval
176	(2)
12.11 Find the student with the top three scores
178	(1)
12.12 Compute all string decompositions
179	(1)
12.13 Test the Collatz conjecture
180	(1)
12.14 Implement a hash function for chess
181	(3)
13 Sorting
184	(17)
13.1 Compute the intersection of two sorted arrays
186	(1)
13.2 Merge two sorted arrays
187	(1)
13.3 Remove first-name duplicates
188	(1)
13.4 Smallest nonconstructible value
189	(1)
13.5 Render a calendar
190	(2)
13.6 Merging intervals
192	(1)
13.7 Compute the union of intervals
193	(2)
13.8 Partitioning and sorting an array with many repeated entries
195	(2)
13.9 Team photo day-1
197	(1)
13.10 Implement a fast sorting algorithm for lists
198	(1)
13.11 Compute a salary threshold
199	(1)
13.12 SORT5
200	(1)
14 Binary Search Trees
201	(23)
14.1 Test if a binary tree satisfies the BST property
203	(2)
14.2 Find the first key greater than a given value in a BST
205	(1)
14.3 Find the k largest elements in a BST
206	(1)
14.4 Compute the LCA in a BST
207	(1)
14.5 Reconstruct a BST from traversal data
208	(2)
14.6 Find the closest entries in three sorted arrays
210	(1)
14.7 Enumerate numbers of the form a + b squar root of 2
211	(3)
14.8 The most visited pages problem
214	(1)
14.9 Build a minimum height BST from a sorted array
215	(1)
14.10 Insertion and deletion in a BST
216	(2)
14.11 Test if three BST nodes are totally ordered
218	(2)
14.12 The range lookup problem
220	(2)
14.13 Add credits
222	(2)
15 Recursion
224	(19)
15.1 The Towers of Hanoi problem
226	(2)
15.2 Generate all nonattacking placements of n-Queens
228	(1)
15.3 Generate permutations
229	(2)
15.4 Generate the power set
231	(2)
15.5 Generate all subsets of size k
233	(1)
15.6 Generate strings of matched parens
234	(1)
15.7 Generate palindromic decompositions
235	(1)
15.8 Generate binary trees
236	(1)
15.9 Implement a Sudoku solver
237	(2)
15.10 Compute a Gray code
239	(1)
15.11 Compute the diameter of a tree
240	(3)
16 Dynamic Programming
243	(25)
16.1 Count the number of score combinations
245	(3)
16.2 Compute the Levenshtein distance
248	(3)
16.3 Count the number of ways to traverse a 2D array
251	(2)
16.4 Compute the binomial coefficients
253	(1)
16.5 Search for a sequence in a 2D array
254	(1)
16.6 The knapsack problem
255	(3)
16.7 The bedbathandbeyond.com problem
258	(2)
16.8 Find the minimum weight path in a triangle
260	(1)
16.9 Pick up coins for maximum gain
261	(1)
16.10 Count the number of moves to climb stairs
262	(1)
16.11 The pretty printing problem
263	(3)
16.12 Find the longest nondecreasing subsequence
266	(2)
17 Greedy Algorithms and Invariants
268	(14)
17.1 Compute an optimum assignment of tasks
269	(1)
17.2 Schedule to minimize waiting time
270	(1)
17.3 The interval covering problem
271	(3)
17.4 The 3-sum problem
274	(1)
17.5 Find the majority element
275	(1)
17.6 The gasup problem
276	(2)
17.7 Compute the maximum water trapped by a pair of vertical lines
278	(1)
17.8 Compute the largest rectangle under the skyline
279	(3)
18 Graphs
282	(17)
18.1 Search a maze
285	(2)
18.2 Paint a Boolean matrix
287	(2)
18.3 Compute enclosed regions
289	(1)
18.4 Deadlock detection
290	(1)
18.5 Clone a graph
291	(1)
18.6 Making wired connections
292	(1)
18.7 Transform one string to another
293	(2)
18.8 Team photo day-2
295	(2)
18.9 Compute a shortest path with fewest edges
297	(2)
19 Parallel Computing
299	(11)
19.1 Implement caching for a multithreaded dictionary
300	(2)
19.2 Analyze two unsynchronized interleaved threads
302	(1)
19.3 Implement synchronization for two interleaving threads
303	(1)
19.4 Implement a thread pool
304	(1)
19.5 Deadlock
305	(1)
19.6 The readers-writers problem
306	(1)
19.7 The readers-writers problem with write preference
307	(1)
19.8 Implement a Timer class
308	(1)
19.9 Test the Collatz conjecture in parallel
309	(1)
III Domain Specific Problems		310	(48)
20 Design Problems
311	(18)
20.1 Design a spell checker
312	(1)
20.2 Design a solution to the stemming problem
313	(1)
20.3 Plagiarism detector
314	(1)
20.4 Pair users by attributes
315	(1)
20.5 Design a system for detecting copyright infringement
316	(1)
20.6 Design TEX
317	(1)
20.7 Design a search engine
317	(1)
20.8 Implement PageRank
318	(2)
20.9 Design TeraSort and PetaSort
320	(1)
20.10 Implement distributed throttling
320	(1)
20.11 Design a scalable priority system
321	(1)
20.12 Create photomosaics
322	(1)
20.13 Implement Mileage Run
322	(2)
20.14 Implement Connexus
324	(1)
20.15 Design an online advertising system
325	(1)
20.16 Design a recommendation system
326	(1)
20.17 Design an optimized way of distributing large files
326	(1)
20.18 Design the World Wide Web
327	(1)
20.19 Estimate the hardware cost of a photo sharing app
328	(1)
21 Language Questions
329	(13)
21.1 Garbage Collection
329	(1)
21.2 Closure
329	(1)
21.3 Shallow and deep copy
330	(1)
21.4 Iterators and Generators
331	(1)
21.5 @decorator
331	(2)
21.6 List vs tuple
333	(1)
21.7 *args and *kwargs
334	(1)
21.8 Python code
335	(1)
21.9 Exception Handling
336	(2)
21.10 Scoping
338	(2)
21.11 Function arguments
340	(2)
22 Object-Oriented Design
342	(6)
22.1 Template Method vs. Strategy
342	(1)
22.2 Observer pattern
343	(1)
22.3 Push vs. pull observer pattern
343	(1)
22.4 Singletons and Flyweights
344	(1)
22.5 Adapters
345	(1)
22.6 Creational Patterns
346	(1)
22.7 Libraries and design patterns
347	(1)
23 Common Tools
348	(10)
23.1 Merging in a version control system
348	(2)
23.2 Hooks
350	(1)
23.3 Is scripting more efficient?
351	(1)
23.4 Polymorphism with a scripting language
352	(1)
23.5 Dependency analysis
352	(1)
23.6 ANT vs. Maven
353	(1)
23.7 SQL vs. NoSQL
354	(1)
23.8 Normalization
354	(1)
23.9 SQL design
355	(1)
23.10 IP, TCP, and HTTP
355	(1)
23.11 HTTPS
356	(1)
23.12 DNS
357	(1)
IV The Honors Class		358	(64)
24 Honors Class
359	(63)
24.1 Compute the greatest common divisor
360	(1)
24.2 Find the first missing positive entry
361	(1)
24.3 Buy and sell a stock k times
362	(1)
24.4 Compute the maximum product of all entries but one
363	(2)
24.5 Compute the longest contiguous increasing subarray
365	(1)
24.6 Rotate an array
366	(2)
24.7 Identify positions attacked by rooks
368	(1)
24.8 Justify text
369	(1)
24.9 Implement list zipping
370	(1)
24.10 Copy a postings list
371	(1)
24.11 Compute the longest substring with matching parens
372	(1)
24.12 Compute the maximum of a sliding window
373	(2)
24.13 Implement a postorder traversal without recursion
375	(2)
24.14 Compute fair bonuses
377	(2)
24.15 Search a sorted array of unknown length
379	(1)
24.16 Search in two sorted arrays
380	(2)
24.17 Find the kth largest element-large n, small k
382	(1)
24.18 Find an element that appears only once
382	(2)
24.19 Find the line through the most points
384	(1)
24.20 Find the shortest unique prefix
385	(2)
24.21 Find the most visited pages in a window
387	(1)
24.22 Convert a sorted doubly linked list into a BST
388	(2)
24.23 Convert a BST to a sorted doubly linked list
390	(1)
24.24 Merge two BSTs
391	(1)
24.25 The view from above
392	(2)
24.26 Implement regular expression matching
394	(3)
24.27 Synthesize an expression
397	(2)
24.28 Count inversions
399	(1)
24.29 Draw the skyline
400	(2)
24.30 Measure with defective jugs
402	(2)
24.31 Compute the maximum subarray sum in a circular array
404	(1)
24.32 Determine the critical height
405	(2)
24.33 Find the maximum 2D subarray
407	(2)
24.34 Implement Huffman coding
409	(3)
24.35 Trapping water
412	(1)
24.36 Search for a pair-sum in an abs-sorted array
413	(3)
24.37 The heavy hitter problem
416	(1)
24.38 Find the longest subarray whose sum
417	(2)
24.39 Road network
419	(1)
24.40 Test if arbitrage is possible
420	(2)
V Notation and Index		422	(1)
Notation		423	(2)
Index of Terms		425	
